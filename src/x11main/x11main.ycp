/**************
FILE          : x11main.ycp
***************
PROJECT       : YaST2
              :
AUTHOR        : Marcus Schäfer <ms@suse.de>
              :
BELONGS TO    : YaST2
              : (X11 integration part using SaX2/ISaX)
              :
DESCRIPTION   : This script setup the base workflow
              : to configure the graphics system based on X11
              : The SaX2 integrated modules are used to
              : provide an automatic suggestion of a possible
              : configuration.
              :
              :
STATUS        : Development
**************/
/**
 * File:        x11main/x11main.ycp
 * Package:     X11 Configuration
 * Summary:     Second stage functions after x11.ycp has been loaded
 * Authors:     Marcus Schaefer <ms@suse.de>
 *
 * $Id$
 */
{
textdomain "x11";

import "XProposal";
import "Mode";
import "Report";
import "Wizard";
import "Popup";
import "Confirm";

include "x11/x11Dialog.ycp";

//==========================================
// Globals...
//------------------------------------------
boolean X11Enabled = true;

//==========================================
// textMode...
//------------------------------------------
define void textMode () ``{
	// ...
	// callback function if the user don`t want to use X11
	// in this case no config file will be written
	// ---
	// y2milestone ("textMode()...");
	// ---
	X11Enabled = false;
	SetTextMode();
}

//==========================================
// autoMode...
//------------------------------------------
define void autoMode () ``{
	//...
	// callback function if the user want to use X11
	// we will enable the dialog controls again
	// ---
	// y2milestone ("autoMode()...");
	// ---
	X11Enabled = true;
	SetX11Mode();
	XProposal::setupRemoteControl();
}

//==========================================
// getSuggestionString...
//------------------------------------------
define string getSuggestionString ( boolean init ) ``{
	// ...
	// create the information string containing the most
	// important information about the graphics system.
	// ---
	string data = "";
	list initResult = [];
	if ( init ) {
		initResult = XProposal::getSuggestion (init);
	} else {
		initResult = XProposal::resetSuggestion ();
	}
	map allCards = initResult[0]:$[];
	map allViews = initResult[1]:$[];
	boolean done = false;
	integer cnr  = 0;
	repeat {
		map currentCard = allCards[cnr]:$[];
		map currentView = allViews[cnr]:$[];
		cnr = cnr + 1;
		if (currentCard == $[]) {
			// ...
			// at the end of the suggestion text we will add the
			// 3D status. Therefore the D3Active variable is handled
			// if the status is false we had to check if the card
			// or the environment is capable of using 3D
			// ---
			data = data + _("3D Acceleration:") + "\n";
			if (XProposal::D3Active) {
				data = data + "  " + _("Enabled");
			} else {
			if (cnr > 2) {
				data = data + "  " + _("Unavailable");
			} else if ( SCR::Execute (
				.target.bash, "/usr/bin/3Ddiag --num-3dboards"
			) == 0) {
				data = data + "  " + _("Unavailable");
			} else {
				data = data + "  " + _("Disabled");
			}
			}
			done = true;
		} else {
			map card = currentCard["Card"]:$[];
			map view = currentView["Desktop"]:$[];
			string cardVendor = card["Vendor"]:"nil";
			string cardModel  = card["Name"]:"nil";
			string cardDriver = card["Driver"]:"nil";
			string moniVendor = view["VendorName"]:"nil";
			string moniModel  = view["ModelName"]:"nil";
			string colorDepth = view["ColorDepth"]:"nil";
			string moniHsync  = view["HorizSync"]:"nil";
			string moniVsync  = view["VertRefresh"]:"nil";
			string modes = "Modes:" + colorDepth;
			string resolution = view[modes]:"nil";
			list resList = splitstring (resolution,",");
			resolution = resList[0]:"nil";

			data = data + _("Card:")
				+ " " + cardVendor + " " + cardModel
				+ " ( " + cardDriver + " )" + "\n";
			data = data + "  " + _("Monitor:");
			if (moniVendor == moniModel) {
				data = data + " " + moniVendor + " [ ";
			} else {
				data = data + " " + moniVendor + " " + moniModel + " [ ";
			}
				data = data + moniHsync + " " + _("kHz") + " / "
					+ moniVsync + " " + _("Hz") + " ]" + "\n";
				data = data + "  " + _("Resolutions:")
					+ " " + resolution + "\n";
				data = data + "  " + _("Color depth:")
					+ " " + colorDepth + " " + _("bit") + "\n\n";
			}
	} until (
		done == true
	);
	return (data);
}

//==========================================
// Open Wizzard window...
//------------------------------------------
if (!Mode::autoinst)
    Wizard::OpenAcceptDialog();

//==========================================
// Initialize...
//------------------------------------------
string suggestion = getSuggestionString (true);

//==========================================
// Check if hardware.chg exist...
//------------------------------------------
XProposal::HWFlag = (SCR::Read (.target.size,
	"/var/cache/sax/files/hardware.chg"
) !=-1);

//==========================================
// Event loop...
//------------------------------------------
string helpText = X11AutoSetupDialogHelpText();
term   contents = X11AutoSetupDialog(
            XProposal::AutoInstallMapEnableX11, suggestion
            );

if (!Mode::autoinst) {
    Wizard::SetContents(
            _("Desktop Settings"),contents, helpText,
            (boolean) WFM::Args(0), (boolean) WFM::Args(1)
            );

}
//==========================================
// Installed system, choose correct mode
//------------------------------------------
if ((! Mode::autoinst) && (! Mode::cont)) {
	string configFile = "/etc/X11/XF86Config";
	boolean configExist = (SCR::Read(.target.size, configFile)!=-1);
	if (! configExist) {
		textMode();
	}
}

//==========================================
// Check if yast2 was called remotely
//------------------------------------------
XProposal::setupRemoteControl();

//==========================================
// conclude directly if auto install mode
//------------------------------------------
if ( Mode::autoinst )
{
	XProposal::concludeConfiguration ( X11Enabled );
	return `next;
}
boolean stop = false;
any ret   = nil;
repeat {
	ret = Wizard::UserInput();
	if ( ret == `abort || ret == `cancel || ret == `back ) {
		XProposal::abortConfiguration();
	}
	if ( ret == `text_mode_only ) {
		textMode();
	}
	if ( ret == `auto_mode ) {
		autoMode();
	}
	if ( ret == `next ) {
		XProposal::concludeConfiguration ( X11Enabled );
	}
	if ( ret == `change ) {
		stop = XProposal::changeConfiguration();
		if (stop) {
			SetTextMode();
			string suggestion = getSuggestionString (false);
			SetX11Mode();
			term   contents = X11AutoSetupDialog (
				true, suggestion
			);
			Wizard::SetContents (
				_("Desktop Settings"),contents, helpText,
				(boolean) WFM::Args(0), (boolean) WFM::Args(1)
			);
			stop = false;
		}
	}
	if ( ret == `reprobe ) {
		SetTextMode();
		SCR::Execute (.target.bash,
			"/bin/rm -f /var/cache/sax/files/*"
		);
		string suggestion = getSuggestionString (true);
		SetX11Mode();
		term   contents = X11AutoSetupDialog (
			true, suggestion
		);
		Wizard::SetContents (
			_("Desktop Settings"),contents, helpText,
			(boolean) WFM::Args(0), (boolean) WFM::Args(1)
		);
	}
} until (
	ret  == `next   ||
	ret  == `back   ||
	ret  == `cancel ||
	stop == true
);
Wizard::CloseDialog();
return (symbol) ret;
}
